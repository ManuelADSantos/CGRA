
<!-- ============================================ Background Color ============================================ -->
<head>
    <style>
      body {
        background-color: rgb(46, 46, 46); /* You can change 'lightblue' to any color you want */
      }
    </style>
</head>

<!-- ============================================ Base Scripts ============================================ -->
<div id="Base Scripts">
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/deecshader.js"></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/deecapp.js"></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/cgraobject.js"></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/cgratexture.js"></script>
    <script src='https://git.io/glm-js.min.js'></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/js-aruco/cv.js"></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/js-aruco/aruco.js"></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/js-aruco/svd.js"></script>
    <script src="https://is3l.isr.uc.pt/~pm/CGRA/JS/js-aruco/posit1.js"></script>
</div>

<!-- ============================================ Get Video Input ============================================ -->
<video id="video" autoplay style="width:320px; height:240px;"></video>

<!-- ============================================ Shaders ============================================ -->
<div id="Shaders">
    <!-- <script id="vertex-shader" type="x-shader/x-vertex">
        precision mediump float;

        attribute  vec3 in_Position;
        attribute  vec3 in_Color;
        attribute vec2 in_texcoords;
        uniform mat4 MVP;

        varying  vec3 ex_Color;
        varying  vec2 vTextureCoord;

        void main()
        {
            gl_Position = MVP * vec4(in_Position.x, in_Position.y, in_Position.z, 1.0);
            vTextureCoord = in_texcoords;
            ex_Color = in_Color;
        }
    </script> -->

    <script id="vertex-shader" type="x-shader/x-vertex">
        precision mediump float;

        // === Inputs
        attribute  vec3 in_Position;
        attribute  vec3 in_Color;
        attribute  vec3 in_Normals;
        attribute vec2 in_Textures;

        // === Outputs to fragment shader
        varying  vec3 Colors;
        varying  vec3 Normals;
        varying  vec4 Position;
        varying  vec2 Textures;

        // === Uniforms
        uniform mat4 MVP;
        uniform mat3 NormalMatrix;
        uniform mat4 MV;

        void main()
        {
            Colors = in_Color;
            Normals = normalize(NormalMatrix * in_Normals);
            Position = MV * vec4(in_Position.x, in_Position.y, in_Position.z, 1.0);
            Textures = in_Textures;
            
            gl_Position = MVP * vec4(in_Position.x, in_Position.y, in_Position.z, 1.0);
        }
    </script>

    <!-- <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying  vec2 vTextureCoord;
        varying  vec3 ex_Color;
    
        uniform sampler2D uSampler;
    
        void main()
        {
            gl_FragColor = texture2D(uSampler, vTextureCoord);
        }
    </script> -->

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
    
        // === Inputs from vertex shader
        varying  vec3 Colors;         // -> Color of the vertex
        varying  vec3 Normals;        // -> Normal of the vertex
        varying  vec4 Position;      // -> Position of the vertex
        varying  vec2 Textures;

        // === Uniforms
        // - Textures
        uniform sampler2D uSampler;
        // - Lights
        uniform vec3 Ambient;           // -> Ambient light color
        uniform vec3 LightColor;        // -> Directional light color
        uniform vec3 LightPosition;    // -> Directional light direction
        uniform vec3 ViewPos;
        // - Materials
        uniform float Shininess;        // -> Shininess of the material (n - sharpness exponent, from 1 to 100)
        uniform float Strength;         // -> Strength of the reflection (Ks - specular coefficient, from 0.1 to 0.7)
        // - Attenuations
        uniform float ConstantAttenuation;
        uniform float LinearAttenuation;
        uniform float QuadraticAttenuation;
        
        
        void main(void)
        {
            // -- Auxiliar vectors
            vec3 LightDirection = LightPosition - vec3(Position);
            float LightDistance = length(LightDirection);
            LightDirection = normalize(LightDirection);
    
            // Model how much light is available for the fragment
            float attenuation = 1.0 / (ConstantAttenuation + LinearAttenuation * LightDistance + QuadraticAttenuation * LightDistance * LightDistance);
            
            vec3 ViewerDir = normalize(ViewPos - vec3(Position));
            vec3 HalfVector = normalize(LightDirection + ViewerDir);
            
            // Ambient part
            vec3 ambientLight = Ambient * Colors;

            // Diffused part
            float diffused_part = max(0.0, dot(Normals, LightDirection));
            vec3 scatteredLight = LightColor * (diffused_part * attenuation);
            
            // Specular part
            float specular_part = max(0.0, dot(Normals, HalfVector));
            if (diffused_part <= 0.0)
                specular_part = 0.0;
            else
                specular_part = pow(specular_part, Shininess)*Strength;
            vec3 reflectedLight = LightColor * (specular_part * attenuation);
    
            vec3 rgb = min((ambientLight + scatteredLight + reflectedLight), vec3(1.0));
            
            gl_FragColor = vec4(rgb, 1.0)*texture2D(uSampler, Textures);
        }
    </script>
</div>

<!-- ============================================ Solids Definitions ============================================ -->
<div id="Solids Definitions">
    <!-- Cubes -->
    <script id="Cube">
        class cube extends CGRAobject
        {
            // ===== Constructor
            constructor(glcontext, color = [1.0, 1.0, 1.0])
            {
                // ===== Initialize the parent class
                super(glcontext); 
                
                // ===== Define Constants
                this.numvertices = 36, this.size = 1;
                let dim = this.size/2;
                this.vertices = [], this.colors = [], this.normals = [], this.texcoords = [];
                
                // ===== List vertices
                var verticesCube = [[ -dim, -dim,  dim],
                                    [-dim,  dim,  dim],
                                    [ dim,  dim,  dim],
                                    [ dim, -dim,  dim],
                                    [-dim, -dim, -dim],
                                    [-dim,  dim, -dim],
                                    [ dim,  dim, -dim],
                                    [ dim, -dim, -dim]];
                                    
                var normalsCube = [ [ 0,  0,  1],  // Front = +Z
                                    [ 1,  0,  0],  // Right = +X
                                    [ 0,  0, -1],  // Back  = -Z
                                    [-1,  0,  0],  // Left  = -X
                                    [ 0,  1,  0],  // Up    = +Y
                                    [ 0, -1,  0]]; // Down  = -Y

                var texturesCube = [[ 0.0, 0.0], //0
                                    [ 0.0, 1.0], //1
                                    [ 1.0, 1.0], //2
                                    [ 1.0, 0.0]];//3

                // ===== Lookup tables
                var indexes_vertex = [
                    0, 1, 2,  2, 3, 0,  // Front face
                    6, 7, 3,  2, 3, 6,  // Right face
                    6, 7, 4,  4, 5, 6,  // Back  face
                    1, 0, 4,  4, 5, 1,  // Left  face
                    1, 5, 6,  6, 2, 1,  // Up    face
                    0, 3, 7,  0, 4, 7]; // Down  face 

                var indexes_normals = [
                    0, 0, 0,  0, 0, 0,  // Front face
                    1, 1, 1,  1, 1, 1,  // Right face
                    2, 2, 2,  2, 2, 2,  // Back  face
                    3, 3, 3,  3, 3, 3,  // Left  face
                    4, 4, 4,  4, 4, 4,  // Up    face
                    5, 5, 5,  5, 5, 5]; // Down  face
                
                var indexes_textures = [
                    1, 0, 3,  3, 2, 1,  // Front face
                    3, 2, 1,  0, 1, 3,  // Right face
                    0, 1, 2,  2, 3, 0,  // Back  face
                    3, 2, 1,  1, 0, 3,  // Left  face
                    1, 0, 3,  3, 2, 1,  // Up    face
                    1, 2, 3,  1, 0, 3]; // Down  face
                
                // ===== Create structures to populate buffers
                for (var i = 0; i < this.numvertices; i++)
                {
                    this.vertices = this.vertices.concat(verticesCube[indexes_vertex[i]]);
                    this.normals = this.normals.concat(normalsCube[indexes_normals[i]]);
                    this.texcoords = this.texcoords.concat(texturesCube[indexes_textures[i]]);
                    this.colors.push(color);
                }
                
                // ===== Creating and configuring buffers
                this.vertexbuffer=this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertices), this.gl.STATIC_DRAW);
                
                this.colorbuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.colors.flat()), this.gl.STATIC_DRAW);

                this.normalsbuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalsbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.normals), this.gl.STATIC_DRAW);

                this.texcoordsbuffer=this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordsbuffer);  
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.texcoords), this.gl.STATIC_DRAW); 
            }
            
            // ===== Set texture
            setTexture(source)
            {
                this.texture = new CGRAtexture(this.gl);
                this.texture.load(source);
                this.textureid = this.texture.textureid;
            }
            
            // ===== Set material properties
            setMaterials(shiny = 50, strength = 0.4)
            {    
                this.Shininess = shiny;
                this.Strength = strength;
            }

            // ===== Function to dinamically change cube color
            setColor(color)
            {
                for (var i = 0; i < this.numvertices; i++)
                {
                    this.colors.push(color);
                }

                this.colorbuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.colors.flat()), this.gl.STATIC_DRAW);
            }
            
            // ===== Function to draw the cube
            drawit(viewMat, projectionMat,parentMat4 = glm.mat4(1.0))
            {
                this.shaderprog.startUsing();
                
                // ===== Setup textures
                this.texcoordsLocation = this.gl.getAttribLocation(this.shaderprog.shaderProgram,"in_Textures");
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.texcoordsbuffer);
                this.gl.vertexAttribPointer(this.texcoordsLocation, // Attribute location
                                2, // number of elements per attribute
                                this.gl.FLOAT,  // Type of elements
                                false,  // 
                                0, //2*Float32Array.BYTES_PER_ELEMENT, // size of a vertex in bytes 
                                0); // Offset from the begining of a single vertex to this attribute
                this.gl.enableVertexAttribArray(this.texcoordsLocation);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.textureid);
                this.texturelocation =  this.gl.getUniformLocation(this.shaderprog.shaderProgram, "uSampler");
                this.gl.uniform1i(this.textureLocation, 0);
                
                // ===== Normals into vertex shader
                this.normloc = this.gl.getAttribLocation(this.shaderprog.shaderProgram,"in_Normals");
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.normalsbuffer);
                this.gl.vertexAttribPointer(this.normloc, // Attribute location
                            3, // number of elements per attribute
                            this.gl.FLOAT,  // Type of elements
                            false,  // 
                            3*Float32Array.BYTES_PER_ELEMENT, // size of a vertex in bytes 
                                0); // Offset from the begining of a single vertex to this attribute
                this.gl.enableVertexAttribArray(this.normloc);
                
                // ===== Normals transformation matrix
                var localT = parentMat4['*'](this.modelMat);
                this. NormMatloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"NormalMatrix");
                var NormMat = glm.mat3(glm.transpose(glm.inverse(localT)));
                this.gl.uniformMatrix3fv(this.NormMatloc, false, NormMat.array);

                // ===== Model transformation matrix
                this.Matloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"MV");
                var MV = viewMat['*'](parentMat4['*'](this.modelMat));
                this.gl.uniformMatrix4fv(this.Matloc, false, MV.array);
                
                // ===== Shininess value (Higher values result in smaller, sharper highlights, while lower values create larger, more diffused highlights. Usually in the range of 1 to 100.)
                this.Shininessloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"Shininess");
                this.gl.uniform1f(this.Shininessloc, this.Shininess);

                // ===== Strength value
                this.Strengthloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"Strength");
                this.gl.uniform1f(this.Strengthloc, this.Strength);

                
                this.shaderprog.stopUsing();

                // the parent method does the rest
                super.drawit(viewMat,projectionMat,parentMat4);
            }  
        }
    </script>

    <!-- Spheres -->
    <script id="Sphere">
        class sphere extends CGRAobject
        {
            // ===== Constructor
            constructor(glcontext, color = [1.0, 1.0, 1.0], faces = 20)
            {
                // ===== Initialize the parent class
                super(glcontext); 
                
                // ===== Define Constants
                // -- Number of faces (3 to inf)
                this.sides = faces;
                // -- Number of vertices
                this.numvertices = (6*this.sides + (6*this.sides)*(this.sides-2));
                this.length = 1; this.radius = 0.5;
                this.vertices = [], this.colors = [], this.normals = [], this.texCoords = [];
                
                // ===== Create circunferences (360/N sides)
                let slices = [];   
                for (let i = 0; i < this.sides; i++)
                { 
                    let theta = i*2*Math.PI/this.sides, aux = [];
                    for (let j = 0; j < this.sides-1; j++)
                    {     
                        aux.push(
                            [(Math.sin((j+1)*Math.PI/this.sides)*this.radius)*Math.cos(theta),
                            Math.cos((j+1)*Math.PI/this.sides)*this.radius,
                            (Math.sin((j+1)*Math.PI/this.sides)*this.radius)*Math.sin(theta)]);
                    }   
                    slices.push(aux);
                }
                slices.push([[0,this.radius,0],[0,-1*this.radius,0]]);
                
                // ===== Create vertex and color data to populate buffers
                for (let i = 0; i < this.sides; i++)
                {            
                    // Top side
                    this.vertices.push(slices[this.sides][0]);
                    this.vertices.push(slices[i][0]);
                    this.vertices.push(slices[(i+1)%this.sides][0]);
                    
                    this.normals.push(slices[this.sides][0]);
                    this.normals.push(slices[i][0]);
                    this.normals.push(slices[(i+1)%this.sides][0]);
                    
                    this.colors.push([color,color,color].flat());

                    this.texCoords.push([1-((i+(1/2))/(this.sides)), 0]);               // topo
                    this.texCoords.push([1-((i+0)/(this.sides)), 1/this.sides]);  // esquerda
                    this.texCoords.push([1-((i+1)/(this.sides)), 1/this.sides]);  // direita
                    
                    // Middle sections
                    for (let j = 0; j < this.sides - 2; j++)
                    {
                        // Triangle 1
                        this.vertices.push(slices[i][j]);
                        this.vertices.push(slices[(i+1)%this.sides][j]);
                        this.vertices.push(slices[i][j+1]);

                        this.normals.push(slices[i][j]);
                        this.normals.push(slices[(i+1)%this.sides][j]);
                        this.normals.push(slices[i][j+1]);
                        
                        this.colors.push([color,color,color].flat());

                        this.texCoords.push([1-((i+0)/(this.sides)), (j+1)/this.sides]); //a
                        this.texCoords.push([1-((i+1)/(this.sides)), (j+1)/this.sides]); //b
                        this.texCoords.push([1-((i+0)/(this.sides)), (j+2)/this.sides]); //c
                        
                        // Triangle 2
                        this.vertices.push(slices[i][j+1]);
                        this.vertices.push(slices[(i+1)%this.sides][j]);
                        this.vertices.push(slices[(i+1)%this.sides][j+1]);
                        
                        this.normals.push(slices[i][j+1]);
                        this.normals.push(slices[(i+1)%this.sides][j]);
                        this.normals.push(slices[(i+1)%this.sides][j+1]);
                        
                        this.colors.push([color,color,color].flat());

                        this.texCoords.push([1-((i+0)/(this.sides)), (j+2)/this.sides]); //c
                        this.texCoords.push([1-((i+1)/(this.sides)), (j+1)/this.sides]); //b
                        this.texCoords.push([1-((i+1)/(this.sides)), (j+2)/this.sides]); //d
                    }
                    
                    // Down side
                    this.vertices.push(slices[i][this.sides - 2]);
                    this.vertices.push(slices[(i+1)%this.sides][this.sides - 2]);
                    this.vertices.push(slices[this.sides][1]);
                    
                    this.normals.push(slices[i][this.sides - 2]);
                    this.normals.push(slices[(i+1)%this.sides][this.sides - 2]);
                    this.normals.push(slices[this.sides][1]);
                    
                    this.colors.push([color,color,color].flat());

                    this.texCoords.push([1-((i+0)/(this.sides)), 1-1/this.sides]);  // esquerda
                    this.texCoords.push([1-((i+1)/(this.sides)), 1-1/this.sides]); // direita
                    this.texCoords.push([1-((i+(1/2))/(this.sides)), 1]);            // bottom
                }
            
                // ===== Creating and configuring buffers
                this.vertexbuffer=this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertices.flat()), this.gl.STATIC_DRAW);
                
                this.colorbuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.colors.flat()), this.gl.STATIC_DRAW);

                this.normalsbuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalsbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.normals.flat()), this.gl.STATIC_DRAW);

                this.texcoordsbuffer=this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordsbuffer);  
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.texCoords.flat()), this.gl.STATIC_DRAW);
            }

            // ===== Set texture
            setTexture(source)
            {
                this.texture = new CGRAtexture(this.gl);
                this.texture.load(source);
                this.textureid = this.texture.textureid;
            }

            // ===== Set material properties
            setMaterials(shiny = 50, strength = 0.4)
            {
                this.Shininess = shiny;
                this.Strength = strength;
            }

            // ===== Function to dinamically change sphere color
            setColor(color)
            {
                for (var i = 0; i < this.numvertices; i++)
                {
                    this.colors.push(color);
                }

                this.colorbuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorbuffer);    
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.colors.flat()), this.gl.STATIC_DRAW);
            }

            // ===== Function to draw the sphere
            drawit(viewMat, projectionMat,parentMat4 = glm.mat4(1.0))
            {
                this.shaderprog.startUsing();
                
                // ===== Setup textures
                this.texcoordsLocation = this.gl.getAttribLocation(this.shaderprog.shaderProgram,"in_Textures");
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.texcoordsbuffer);
                this.gl.vertexAttribPointer(this.texcoordsLocation, // Attribute location
                                2, // number of elements per attribute
                                this.gl.FLOAT,  // Type of elements
                                false,  // 
                                0, //2*Float32Array.BYTES_PER_ELEMENT, // size of a vertex in bytes 
                                0); // Offset from the begining of a single vertex to this attribute
                this.gl.enableVertexAttribArray(this.texcoordsLocation);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.textureid);
                this.texturelocation =  this.gl.getUniformLocation(this.shaderprog.shaderProgram, "uSampler");
                this.gl.uniform1i(this.textureLocation, 0);
                
                // ===== Normals into vertex shader
                this.normloc = this.gl.getAttribLocation(this.shaderprog.shaderProgram,"in_Normals");
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.normalsbuffer);
                this.gl.vertexAttribPointer(this.normloc, // Attribute location
                            3, // number of elements per attribute
                            this.gl.FLOAT,  // Type of elements
                            false,  // 
                            3*Float32Array.BYTES_PER_ELEMENT, // size of a vertex in bytes 
                                0); // Offset from the begining of a single vertex to this attribute
                this.gl.enableVertexAttribArray(this.normloc);
                
                // ===== Normals transformation matrix
                var localT = parentMat4['*'](this.modelMat);
                this. NormMatloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"NormalMatrix");
                var NormMat = glm.mat3(glm.transpose(glm.inverse(localT)));
                this.gl.uniformMatrix3fv(this.NormMatloc, false, NormMat.array);

                // ===== Model transformation matrix
                this.Matloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"MV");
                var MV = viewMat['*'](parentMat4['*'](this.modelMat));
                this.gl.uniformMatrix4fv(this.Matloc, false, MV.array);
                
                // ===== Shininess value (Higher values result in smaller, sharper highlights, while lower values create larger, more diffused highlights. Usually in the range of 1 to 100.)
                this.Shininessloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"Shininess");
                this.gl.uniform1f(this.Shininessloc, this.Shininess);

                // ===== Strength value
                this.Strengthloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"Strength");
                this.gl.uniform1f(this.Strengthloc, this.Strength);
                
                this.shaderprog.stopUsing();

                // the parent method does the rest
                super.drawit(viewMat,projectionMat,parentMat4);
            }
        }
    </script>

    <!-- Cylinders -->

    <!-- Cones -->

    <!-- Discs -->

</div>

<!-- ============================================ Solar System Definition ============================================ -->
<div id="SolarSystem">

</div>

<!-- ============================================ Bouncing Cylinder Definition ============================================ -->
<div id="BouncingCylinder">

</div>

<!-- ============================================ AR Application ============================================ -->
<div id="AR_Scene">
    <canvas id="Testes" width="600" height="600"
        style="border:2px solid #000000;">
        Error: Your browser does not support the HTML canvas tag.
    </canvas>
    <script id="Testes">
        class Testes_App extends DEECapp
        {
            counter = 0;
            initialize()
            {
                // ===== Perform initializations
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.clearColor(0.1, 0.1, 0.1, 1.0);
                
                // ===== Initialize shader
                var fragsrc = document.getElementById("fragment-shader").text;
                var vertsrc = document.getElementById("vertex-shader").text;
                this.shaderprog = new DEECshader(this.gl);
                this.shaderprog.srcShaders(vertsrc,fragsrc);
                
                // ===== Instantiate cubes
                this.myCube = new cube(this.gl);
                this.myCube.setShader(this.shaderprog);
                this.myCube.setMaterials(100,10);
                this.myCube.setTexture("Diamond.jpg");
                
                this.mySphere = new sphere(this.gl);
                this.mySphere.setShader(this.shaderprog);
                this.mySphere.setMaterials(10,10);
                this.mySphere.setTexture("EarTex.jpg");

                // ===== Set camera
                this.viewpos = glm.vec3(0, 0, 6);

                // ===== Set lights
                this.setLights();

                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                //glm.radians(45): Esse argumento especifica o campo de visão em graus. Aqui, você está usando um campo de visão de 45 graus.             //       
                //1: A razão de aspecto (aspect ratio) da janela ou tela. No seu caso, a razão de aspecto é 1, o que significa que a janela é um quadrado.//
                //0.1: O valor mais próximo em relação à câmera em coordenadas de profundidade.                                                           //
                //1000: O valor mais distante em relação à câmera em coordenadas de profundidade.                                                         // 
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                this.projectionM= glm.perspective(glm.radians(45),1.0,0.1,100);      
                
                //////////////////////////////////////////////////////////////////////////
                //glm.vec3(3, 3, 5): A posição da câmera no espaço 3D.                  //
                //glm.vec3(0, 0, 0): O ponto para o qual a câmera está direcionada.    //
                //glm.vec3(0, 1, 0): A orientação da "parte de cima" da câmera.         //
                //////////////////////////////////////////////////////////////////////////
                this.viewM = glm.lookAt(this.viewpos,glm.vec3(0,0,0),glm.vec3(0,1,0));        
                
                
            }

            setLights()
            {
                // ===== Set parameters of light
                this.shaderprog.startUsing();
                // -- Ambient Light
                this.Ambientloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"Ambient");
                var ambient_light = glm.vec3(0.2);
                this.gl.uniform3fv(this.Ambientloc, ambient_light.array);
                // -- Directional Light Color
                this.LightColorloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"LightColor");
                var color_light = glm.vec3(1.0);
                this.gl.uniform3fv(this.LightColorloc, color_light.array);
                // -- Directional Light Position
                this.LightPosloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"LightPosition");
                var light_pos = glm.vec3(2.0, 2.0, 2.0);
                this.gl.uniform3fv(this.LightPosloc, light_pos.array);
                // -- View Position
                this.ViewPosloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"ViewPos");
                this.gl.uniform3fv(this.ViewPosloc, this.viewpos.array);
                
                // ----- Attenuations
                // -- Constant Attenuation
                this.ConstantAttenuationloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"ConstantAttenuation");
                this.gl.uniform1f(this.ConstantAttenuationloc, 1.0);
                // -- Linear Attenuation
                this.LinearAttenuationloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"LinearAttenuation");
                this.gl.uniform1f(this.LinearAttenuationloc, 0.09);
                // -- Quadratic Attenuation
                this.QuadraticAttenuationloc = this.gl.getUniformLocation(this.shaderprog.shaderProgram,"QuadraticAttenuation");
                this.gl.uniform1f(this.QuadraticAttenuationloc, 0.032);
                // -- Setup done
                this.shaderprog.stopUsing();
            }

            render()
            {
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                this.counter++;
            
                // ==================== Cube ====================
                // ===== Model
                var model = glm.mat4(glm.mat3(1.0));
                // ===== Translations
                var translation = glm.vec3(-1.0, 1.0, 0.0);
                model = glm.translate(model, translation);
                // ===== Rotation
                var rotation = glm.radians(this.counter);
                var axis = glm.vec3(0.0, 1.0, 0.0);
                model = glm.rotate(model, rotation, axis);
                rotation = glm.radians(this.counter*2);
                axis = glm.vec3(0.0, 0.0, 1.0);
                model = glm.rotate(model, rotation, axis);
                // ===== Final Transformation
                this.myCube.setModelTransformation(model); 
                // ===== Draw Cube 
                this.myCube.drawit(this.viewM,this.projectionM);

                // ==================== Sphere ====================
                // ===== Model
                var model = glm.mat4(glm.mat3(1.0));
                // ===== Translations
                var translation = glm.vec3(1.0, 1.0, 0.0);
                model = glm.translate(model, translation);
                // ===== Rotation
                var rotation = glm.radians(this.counter);
                var axis = glm.vec3(0.0, 1.0, 0.0);
                // model = glm.rotate(model, rotation, axis);
                // rotation = glm.radians(180);
                // axis = glm.vec3(0.0, 0.0, 1.0);
                model = glm.rotate(model, rotation, axis);
                // ===== Final Transformation
                this.mySphere.setModelTransformation(model);
                // ===== Draw Sphere
                this.mySphere.drawit(this.viewM,this.projectionM);
                
            }
        }

        var app = new Testes_App('Testes');

        app.run();

    </script>
</div>
